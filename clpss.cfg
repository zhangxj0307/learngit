#!CLPSS
include_file "basic.cfg"


#!define WITH_MYSQL
#!define WITH_AUTH
#!define WITH_IPAUTH
#!define WITH_USRLOCDB
#!define WITH_NAT
#!define WITH_DEBUG
#!define WITH_BLOCK3XX

####### Global Parameters #########

########### VERSION clpss_reg_4.1.5.1 ##############
#!define VERSION "reg_4.1.5.1"

fork=yes
max_while_loops=10000

/* uncomment the next line to disable TCP (default on) */
#disable_tcp=yes

/* uncomment the next line to disable the auto discovery of local aliases
   based on reverse DNS on IPs (default on) */
auto_aliases=no


server_signature=no


/* port to listen to
 * - can be specified more than once if needed to listen on many ports */
port=PORT

#!ifdef WITH_TLS
enable_tls=yes
#!endif

# life time of TCP connection when there is no traffic
# - a bit higher than registration expires to cope with UA behind NAT
tcp_connection_lifetime=7200
tcp_send_timeout=4

####### Custom Parameters #########

# These parameters can be modified runtime via RPC interface
# - see the documentation of 'cfg_rpc' module.
#
# Format: group.id = value 'desc' description
# Access: $sel(cfg_get.group.id) or @cfg_get.group.id
#

####### Modules Section ########

# set paths to location of modules (to sources or installation folders)
#!ifdef WITH_SRCPATH
mpath="modules_k:modules"
#!else
mpath="/app/clpss/lib64/modules_k/:/app/clpss/lib64/modules/"
#!endif

#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
loadmodule "sqlops.so"
#!endif

loadmodule "mi_fifo.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "utils.so"
loadmodule "xlog.so"
loadmodule "avpops.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "mi_rpc.so"
loadmodule "uac.so"
loadmodule "msilo.so"
loadmodule "sdpops.so"
loadmodule "timer.so"
loadmodule "dispatcher.so"

#!ifdef USE_STATSD
loadmodule "statsd.so"
#!endif

#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!ifdef WITH_IPAUTH
loadmodule "permissions.so"
#!endif
#!endif

#!ifdef WITH_PRESENCE
loadmodule "presence.so"
loadmodule "presence_xml.so"
#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
#!endif

#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "htable.so"
loadmodule "pike.so"
#!endif

#!ifdef WITH_XMLRPC
loadmodule "xmlrpc.so"
#!endif

loadmodule "carrierroute.so"

loadmodule "ndb_redis.so"
loadmodule "htable.so"


loadmodule "xhttp.so"
loadmodule "websocket.so"
tcp_accept_no_cl=yes

# ----------------- setting module-specific parameters ---------------

modparam("htable", "db_url", DBURL)
modparam("htable", "key_name_column", "kname")
modparam("htable", "key_type_column", "ktype")
modparam("htable", "value_type_column", "vtype")
modparam("htable", "key_value_column", "kvalue")
modparam("htable", "fetch_rows", 500)

modparam("htable", "htable", "pushlist=>size=128;dbtable=ccp_offlinemsg_push;initval=0;")
modparam("htable", "htable", "userstatelist=>size=1024;dbtable=ccp_userstate_push;initval=0;")
modparam("htable", "htable", "reguserlist=>size=2048;autoexpire=3600;initval=0;")
#modparam("htable", "htable", "callidlist=>size=1024;autoexpire=3600;initval=0;")
#cdr信息,存储内容格式：
#callid|prefix|ipgroup|fs_id|from|to|caller_media_ip|caller_media_port|source_ip|source_port|client_ip|invite_ts|dest_ip|dest_port|ring_ts|answer_ts|callee_media_ip|callee_media_port|voice_codec|end_ts|reason|user_agent|last_code|call_result
modparam("htable", "htable", "callcdrlist=>size=1024;autoexpire=10800;initval=0;")
modparam("htable", "htable", "connectedcalls=>size=512;autoexpire=10800;initval=0;")
modparam("htable", "htable", "prefixlist=>size=512;initval=0;")
modparam("htable", "htable", "app_group=>size=512;dbtable=view_app_group;initval=0;")

modparam("carrierroute", "config_source", "db")
modparam("carrierroute", "db_url", DBURL)
modparam("carrierroute", "match_mode", 128)
modparam("carrierroute", "carrierfailureroute_table", "view_carrierfailureroute")

loadmodule "rtimer.so"
modparam("rtimer", "timer", "name=tus;interval=60;mode=1;")
modparam("rtimer", "exec", "timer=tus;route=timer_options")

#!ifdef USE_STATSD
modparam("rtimer", "timer", "name=stats;interval=10;mode=1;")
modparam("rtimer", "exec", "timer=stats;route=stats_rt")
modparam("statsd", "ip", STATSD_HOST)
modparam("statsd", "port", STATSD_PORT)
#!endif


modparam("ndb_redis", "server", REDISURL0)
modparam("ndb_redis", "server", REDISURL1)
#redis请求超时：毫秒
modparam("ndb_redis", "timeout", REDIS_TIMEOUT)

# ----- mi_fifo params -----
modparam("mi_fifo", "fifo_name", "/app/clpss/sbin/clpss_fifo")

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 4000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer",90000)
modparam("tm","local_ack_mode", 2);
modparam("tm","auto_inv_100_reason", "Trying");



# ----- rr params -----
# add value to ;lr param to cope with most of the UAs
modparam("rr", "enable_double_rr", 1)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 1)


# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
/* uncomment the next line to disable parallel forking via location */
# modparam("registrar", "append_branches", 0)
/* uncomment the next line not to allow more than 10 contacts per AOR */
modparam("registrar", "max_contacts", 1)
# max value for expires of registrations
modparam("registrar", "max_expires", 3600)
# set it to 1 to enable GRUU
modparam("registrar", "gruu_enabled", 0)
#modparam("registrar","default_q",0);
#modparam("registrar","append_branches",0);

# ----- usrloc params -----
/* enable DB persistency for location entries */
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", 0)
#!endif


# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "password_column", "password")
#modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", 0)

# ----- permissions params -----
#!ifdef WITH_IPAUTH
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)
modparam("permissions", "address_table", "view_ip_info")
#!endif

#!endif

#!ifdef WITH_PRESENCE
# ----- presence params -----
modparam("presence", "db_url", DBURL)

# ----- presence_xml params -----
modparam("presence_xml", "db_url", DBURL)
modparam("presence_xml", "force_active", 1)
#!endif


#!ifdef WITH_NAT
# ----- nathelper params -----

# params needed for NAT traversal in other modules
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
#!endif


#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/app/clpss/etc/tls.cfg")
#!endif

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
#!endif

#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif


# ----- msilo params -----
modparam("msilo", "db_url", DBURL)
modparam("msilo","content_type_hdr","Content-Type: text/plain\r\n")
modparam("msilo", "expire_time", 604800)
modparam("msilo", "check_time", 600)
modparam("msilo", "clean_period", 3)
modparam("msilo", "extra_hdrs", "X-Extra: ko\r\n")


#!ifdef WITH_MYSQL
modparam("db_mysql", "timeout_interval", MYSQL_TIMEOUT)
modparam("db_mysql", "auto_reconnect", 1)
#!ifdef DBURL
modparam("db_mysql", "backup_url", DBURL)
#!endif
#modparam("db_mysql", "passwd_encrypt", 1)
modparam("sqlops", "sqlcon", SQLOPS_DB)
modparam("sqlops", "sqlres", "ra")
#!endif

modparam("timer", "declare_timer", "version=write_version,1000,slow,enable");



# ----- dispatcher params -----
#modparam("dispatcher", "list_file", "/app/clpss/etc/dispatcher.list")
modparam("dispatcher", "db_url", IM_DBURL)
modparam("dispatcher", "table_name", "view_sipgw_dispatcher")
modparam("dispatcher", "flags", 3)
modparam("dispatcher", "dst_avp", "$avp(dsdst)")
modparam("dispatcher", "grp_avp", "$avp(dsgrp)")
modparam("dispatcher", "cnt_avp", "$avp(dscnt)")
modparam("dispatcher", "dstid_avp", "$avp(dsdstid)")
modparam("dispatcher", "attrs_avp", "$avp(dsattrs)")
modparam("dispatcher", "ds_ping_from", "sip:CLPSS@LOCALIP")
modparam("dispatcher", "ds_ping_interval", 5)
modparam("dispatcher", "ds_probing_mode", 1)
modparam("dispatcher", "ds_hash_size", 64)
modparam("dispatcher", "ds_hash_expire", 3600)
modparam("dispatcher", "ds_hash_initexpire", 60)



####### Routing Logic ########

# Main SIP request routing logic
# - processing of any incoming SIP request starts with this route
# - note: this is the same as route { ... }
request_route {

    xlog("L_NOTICE","key=RECV_REQUEST|src_ip=$si|src_port=$sp|method=$rm|ru=$ru|fu=$fu|tu=$tu|callid=$ci\n"); 
    xlog("L_INFO", "key=RECV_REQUEST|msg=$mb|callid=$ci\n"); 

    route(REQINIT);
    route(NATDETECT);
    route(MSG);

    if (is_method("CANCEL"))
    {
        #sht_rm_name_re("callidlist=>$ci");
        if (t_check_trans()) {
            if ($sht(callcdrlist=>$ci) == 0)
                $sht(callcdrlist=>$ci) = $(hdr(Reason){re.subst,/ //g}) + "|" + $(hdr(User-Agent){re.subst,/ //g});
            route(RELAY);
        }
        exit;
    }

    if(is_method("BYE"))
    {
        #sht_rm_name_re("callidlist=>$ci");            
        sht_rm_name_re("connectedcalls=>$ci");            
        $var(cdrinfo) = $sht(callcdrlist=>$ci);
        if ($var(cdrinfo) == 0) {
            xlog("L_NOTICE","key=shouldNotHappen|debug=bye without cdrinfo|callid=$ci\n");
        } else {
            $avp(cdr) = $var(cdrinfo) + "|" + $TS + "|" + $(hdr(Reason){re.subst,/ //g}) + "|" + $(hdr(User-Agent){re.subst,/ //g}) +  "|200|1";
            route(cdr_record);
        }
    }

    # handle requests within SIP dialogs
    route(WITHINDLG);

    # authentication
    route(AUTH);

    if(is_method("OPTIONS"))
    {
        if ($fU == "CallRouteGW") {
            sl_send_reply("200","OK");
            exit;
        }
        sl_send_reply("200", "OK");
        exit;
    }


    if(is_method("NOTIFY"))
    {
        if (lookup("location")) {
            route(RELAY);
        } else {
            sl_send_reply("404", "Not Found");  
        }
        exit;
    }

    remove_hf("Route");
    if (is_method("INVITE|SUBSCRIBE"))
        record_route_preset(LOCALIP+":"+PORT+";transport=$pr");	

    # handle registrations
    route(REGISTRAR);

    if ($rU==$null)
    {
        # request with no Username in RURI
#!ifdef USE_STATSD
        statsd_incr("voip.InvalidRequestURI._t_moduleName." + MYNAME);
#!endif
        xlog("L_ERR","key=InvalidRequestURI|code=484|rU=$rU|tU=$tU|fU=$fU|debug=rU invalid|callid=$ci\n");
        sl_send_reply("484","Address Incomplete");
        exit;
    }

    if (!is_method("INVITE|SUBSCRIBE")) {
#!ifdef USE_STATSD
        statsd_incr("voip.shouldNotHappen.exceptedMethod._t_moduleName." + MYNAME + "._t_method." + $rm);
#!endif
        xlog("L_ERR","key=shouldNotHappen.exceptedMethod|method=$rm|msg=$mb|callid=$ci\n");
        exit;
    }

#!ifdef USE_STATSD
    statsd_incr("voip.regclpss.SIPINVITE._t_moduleName." + MYNAME);
#!endif
    #$sht(callidlist=>$ci) = $src_ip + "#" + $sp + "#" + $fU;  

    $rU=$(rU{s.replace,+,00});
    $tU=$(tU{s.replace,+,00});

    if($(rU{s.substr,0,2})=="fs")
    {
#!ifdef WITH_IPAUTH
        if(!allow_source_address())
        {
            xlog("L_ERR","key=ipban|src_ip=$si|src_port=$sp|msg=$mb|callid=$ci\n");
#!ifdef USE_STATSD
            statsd_incr("voip.ipban._t_moduleName." + MYNAME);
#!endif
            exit;
        }
#!endif

        strip(2);
        msg_apply_changes();
        remove_hf("Content-Disposition");
        remove_hf_re("^X-");
        remove_hf("Remote-Party-ID");
        $tU=$(tU{s.strip,2});
        if ($rU =~ "\$")
        {
            route(CallRoute_DISPATCH);
        }


        if($(rU{s.substr,0,1})=="8")
        {
            if(redis_cmd("redis01", "GET k001$rU", "r")) 
            {	
                if(($redis(r=>value)=~"^[0-9|\.]{7,15}$") && $redis(r=>value) != LOCALIP && $redis(r=>value) != INTERNALIP)
                {	
                    $du = "sip:" + $redis(r=>value) + ":"+PORT+";transport=" +$pr;
                    $ru = "sip:fs" + $rU + "@" + $redis(r=>value) + ":"+PORT+";transport=" +$pr;
                    route(RELAY);
                    exit;
                }
            }
            else
            {
#!ifdef USE_STATSD
                statsd_incr("voip.redisFail._t_moduleName." + MYNAME);
#!endif
                xlog("L_ERR","key=redisError|errorType=$redis(r=>type)|errorVal=$redis(r=>value)|errorInfo=$redis(r=>info)|cmd=Get k001$rU|callid=$ci\n");
            }
        }
        route(LOCATION);
        exit;
    }
    else if($(rU{s.substr,0,2})=="re")
    {
#!ifdef WITH_IPAUTH
        if(!allow_source_address())
        {
            xlog("L_ERR","key=ipban|src_ip=$si|src_port=$sp|msg=$mb|callid=$ci\n");
#!ifdef USE_STATSD
            statsd_incr("voip.ipban._t_moduleName." + MYNAME);
#!endif	  
            exit;
        }
#!endif
        $avp(scanPrefix) = $(rU{s.substr,2,0});
        //获取被叫的虚商ID
        if (is_present_hf("P-Call-Inter-UserData")) {
            $var(i) = 0;
            while($var(i) < 3) {
                $var(tmp) = $(hdr(P-Call-Inter-UserData){s.select,$var(i),;});
                if($(var(tmp){s.select,0,=}) == "outcarrier") {
                    $avp(ipgroup) = $(var(tmp){s.select,1,=});
                    break;
                } 
                $var(i) = $var(i) + 1;
            }
        } else {
            $avp(ipgroup) = "default";
        }
        
        $avp(SipPrefix) = $(fU{s.select,0,$});
        if($(avp(SipPrefix){s.len}) == $(fU{s.len})){
            # not from new platform
            if($(fU{s.len}) == 14)
                $avp(SipPrefix) = $(fU{s.substr,0,6});
            else if($(fU{s.len}) == 16)
                $avp(SipPrefix) = $(fU{s.substr,0,8});
        }

        route(route2next);
    }

    #获取到主叫的media ip and media port
    $var(media_ip) = "";
    if(sdp_get_line_startswith("$avp(cline)", "c=IN") == 1){
        $var(media_ip) = $(avp(cline){s.select,2, });
    } else {
        xlog("L_ERR","key=sdp|debug=can not get sdp line start with c=IN for message $rb|callid=$ci\n");
    }

    $var(media_port) = "";
    if(sdp_get_line_startswith("$avp(cline)", "m=audio") == 1){
        $var(media_port) = $(avp(cline){s.select,1, });
    } else {
        xlog("L_ERR","key=sdp|debug=can not get sdp line start with m=audio for message $rb|callid=$ci\n");
    }



    if($(rU{s.substr,0,1})=="8")
    {
#!ifdef USE_STATSD
        statsd_start("voip.redis.timecost._t_moduleName." + MYNAME);
#!endif	  
        if(redis_cmd("redis01", "GET k001$tU", "r")) 
        {	
#!ifdef USE_STATSD
            statsd_stop("voip.redis.timecost._t_moduleName." + MYNAME);
#!endif	  
            if(($redis(r=>value)=~"^[0-9|\.]{7,15}$") && $redis(r=>value) != LOCALIP && $redis(r=>value) != INTERNALIP)
            {	
                $du = "sip:" + $redis(r=>value) + ":"+PORT+";transport=" +$pr;
                $ru = "sip:km" + $rU + "@" + $redis(r=>value) + ":"+PORT+";transport=" +$pr;
                route(RELAY);
                exit;
            }
        }
        else
        {
#!ifdef USE_STATSD
            statsd_stop("voip.redis.timecost._t_moduleName." + MYNAME);
            statsd_incr("voip.redisFail._t_moduleName." + MYNAME);
#!endif	  
            xlog("L_ERR","key=redisError|errorType=$redis(r=>type)|errorVal=$redis(r=>value)|errorInfo=$redis(r=>info)|cmd=Get k001$tU|callid=$ci\n");
        }
    }

    #会议
    $avp(conftag)=0;
    if($(rU{s.substr,0,3})=="400" && $(rU{s.len})==18)
    {
#!ifdef USE_STATSD
        statsd_incr("voip.INVITE.conf._t_moduleName." + MYNAME + "._t_prefix.400");
#!endif	  
        $avp(conftag)=1;
        $avp(freeswitchid)=$(rU{s.substr,10,5});
        $var(prefix) = "400";
    }

    if($(rU{s.substr,0,4})=="conf" && $(rU{s.len})> 11 && $(rU{s.len})< 48)
    {
#!ifdef USE_STATSD
        statsd_incr("voip.INVITE.conf._t_moduleName." + MYNAME + "._t_prefix.conf");
#!endif	  
        $avp(conftag)=1;
        $avp(freeswitchid)=$(rU{s.substr,14,5});
        $var(prefix) = "conf";
    }

    #新会议
    if($(rU{s.substr,0,5})=="nconf")
    {
#!ifdef USE_STATSD
        statsd_incr("voip.INVITE.conf._t_moduleName." + MYNAME + "._t_prefix.conf");
#!endif   
        $avp(conftag)=1;
        $var(confid) = $(rU{s.substr,5,0});
        if(redis_cmd("redis00", "HMGET k501confinfo$var(confid) cmId", "r")) 
        {     
            if($redis(r=>value[0])!=$null && $redis(r=>value[0])!="")
            {
                xdbg("type=getconfcmid|cmid=$redis(r=>value[0])|callid=$ci\n");
                $avp(freeswitchid)=$redis(r=>value[0]);
            }
        }
        else
        {   
            xlog("L_ERR","key=redisError|errorType=$redis(r=>type)|errorVal=$redis(r=>value[0])|errorInfo=$redis(r=>info)|cmd=HMGET k501confinfo$var(confid) cmId|callid=$ci\n");
        }
        $var(prefix) = "conf";
    }

    if($avp(conftag)==1)
    {
        $mf=DCNUM;
        if(!cr_route("default","default","fs$avp(freeswitchid)","$rU", "call_id","$avp(desc)"))
        {
            xlog("L_ERR","key=sipHandleError cr_route fail|freeswitchid=$avp(freeswitchid)|ru=$ru|debug=no route|callid=$ci\n");
#!ifdef USE_STATSD
            statsd_incr("voip.sipHandleError._t_moduleName." + MYNAME);
#!endif
            $avp(cdr) = $ci + "|" + $var(prefix) + "||" + $avp(freeswitchid) + "|" + $fU + "|" + $tU + "|" + $var(media_ip) + "|" + $var(media_port) + "|" + $si + "|" + $sp + "||" + $TS + "||||||||" + $TS + "|;cause=112;text=\"CLPSS_NoCrRoute\"|CLPSS_4.1.4|404|0";
            route(cdr_record);
            sl_send_reply("404", "No route to destination");
        }
        else
        {
            #cdr
            $avp(callinfo) = $ci + "|" + $var(prefix) + "||" + $avp(freeswitchid) + "|" + $fU + "|" + $tU + "|" + $var(media_ip) + "|" + $var(media_port) + "|" + $si + "|" + $sp + "||" + $TS;
            $avp(dst_ip) = $(ru{uri.host});
            $avp(dst_port) = $(ru{uri.port});
            $avp(carrier) = "default";
            $avp(domain) = "default";
            $avp(prefix) = "fs" + $avp(freeswitchid);
            $avp(host)= $rd+":"+$rp;    
            $ru = $ru + ";transport=" + $pr;
            xlog("L_NOTICE","key=cr_route success|freeswitchid=$avp(freeswitchid)|tu=$tu|ru=$ru|callid=$ci\n");
            route(RELAY);			  
        }
        exit;
    }

    if (is_present_hf("P_ClientIP")) {
        $var(ip) = $hdr(P_ClientIP);
    } else {
        $var(ip) = $si;
    }
    $avp(ipgroup) = "default";
#!ifdef ROUTE_SQL

    mysql_inet_aton("$var(ip)", "$var(result)");

#!ifdef USE_STATSD
    statsd_start("voip.mysql.timecost._t_moduleName." + MYNAME);
#!endif
    sql_query("ca", "SELECT t.virtual_carrier_group  FROM sys_cfg_ip_carrier t WHERE t.network_addr_aton<=$var(result) AND t.broadcast_addr_aton>=$var(result) LIMIT 1", "ra");
#!ifdef USE_STATSD
    statsd_stop("voip.mysql.timecost._t_moduleName." + MYNAME);
#!endif
    if($dbr(ra=>rows)>0)
    {
        if ($dbr(ra=>[0,0]) != "000000")
        {
            $avp(ipgroup) = $dbr(ra=>[0,0]);
        }
    }
    else
    {
#!ifdef USE_STATSD
        statsd_incr("voip.mysqlFail._t_moduleName." + MYNAME);
#!endif
        xlog("L_ERR","key=Warning|ip=$var(ip)|debug=cannot get ipgroup from mysql, setto default|callid=$ci\n");
    }
#!endif

    #cdr
    $avp(callinfo) = $ci + "|" + $var(SipPrefix) + "|" + $var(ipgroup) + "||" + $fU + "|" + $tU + "|" + $var(media_ip) + "|" + $var(media_port) + "|" + $si + "|" + $sp + "|" + $var(ip) + "|" + $TS;

    $var(userdata) = "incarrier=" + $avp(ipgroup);
    if (is_present_hf("P-Call-Inter-UserData")) {
        $var(userdata) = $var(userdata) + ";" + $hdr(P-Call-Inter-UserData);
        remove_hf("P-Call-Inter-UserData");
    }
    insert_hf("P-Call-Inter-UserData: $var(userdata)\r\n");
    xlog("L_NOTICE","key=info|ip=$var(ip)|ip group=$avp(ipgroup)|callid=$ci\n");

    $avp(SipPrefix) = $(fU{s.select,0,$});
    if($(avp(SipPrefix){s.len}) == $(fU{s.len})){
        # not from new platform
        if($(fU{s.len}) == 14)
            $avp(SipPrefix) = $(fU{s.substr,0,6});
        else if($(fU{s.len}) == 16)
            $avp(SipPrefix) = $(fU{s.substr,0,8});
    }
    $avp(scanPrefix) = $rU;

    route(route2next);
}


route[RELAY] {

    # enable additional event routes for forwarded requests
    # - serial forking, RTP relaying handling, a.s.o.
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
        t_set_fr(0, CLPSS2MS_TIMEOUT);
    }

    if (!t_relay()) {
        $var(rc) = $rc;
#!ifdef USE_STATSD
        statsd_incr("voip.sipHandleError._t_moduleName." + MYNAME);
#!endif
        xlog("L_ERR","key=sipHandleError|fu=$fu|tu=$tu|ru=$ru|rc=$var(rc)|relay error|callid=$ci\n");
        //重新路由
        revert_uri();
        $mf=DCNUM;
        if (!cr_next_domain("$avp(carrier)", "$avp(domain)", "$avp(prefix)",
                    "$avp(host)", "460", "$avp(domain)")) {
            xlog("key=reroute|cr_next_domain failed|callid=$ci\n");
            exit;
        }     
        if (!cr_route("$avp(carrier)", "$avp(domain)", "$avp(prefix)", "$rU",
                    "call_id")) {
            xlog("key=reroute|cr_route failed|callid=$ci\n");
            exit;
        }     
        xlog("key=reroute|next_domain=$avp(domain)|ru=$ru|cr_route next carrier|callid=$ci\n");
        $avp(host)= $rd+":"+$rp;
        route(RELAY);

        #sl_reply_error();
    } else {
        xlog("L_NOTICE","key=SEND_TO|du=$du|ru=$ru|callid=$ci\n");
    }
    exit;
}


# Dispatch requests
route[CallRoute_DISPATCH] {
        
	if ($rU =~ "\$") {
	  $var(prefix) = $(rU{s.select,0,$});
	} else {
	if ($(rU{s.len})==14) {
          $var(prefix) = $(rU{s.substr,0,6});
	} else {
	  $var(prefix) = $(rU{s.substr,0,8});
	  }
	}
        $var(groupid) = $sht(app_group=>$var(prefix));
        if ($var(groupid)==0) {
          $var(groupid)=1;
        }
        xlog("L_NOTICE","callid=$ci|rU=$rU|prefix=$var(prefix)|groupid=$var(groupid)\n");

	# round robin dispatching on gateways group '1'
	#if(!ds_select_dst("1", "9"))
	if(!ds_select_dst($var(groupid), "4"))
	{
#!ifdef USE_STATSD
        statsd_incr("voip.dispatchFail._t_moduleName." + MYNAME);
#!endif
        xlog("L_ERR","callid=$ci|key=dispatchFail|fU=$fU|tU=$tU\n");
		send_reply("404", "No destination");
		exit;
	}
	xlog("L_NOTICE","callid=$ci|debug=dispatch to $du\n");
	$avp(dip) = $(du{uri.host});
	route(RELAY);
	exit;
}



# Per SIP request initial checks
### REQINIT START ###
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
    # flood dection from same IP and traffic ban for a while
    # be sure you exclude checking trusted peers, such as pstn gateways
    # - local host excluded (e.g., loop to self)
    if(src_ip!=myself)
    {
        if($sht(ipban=>$si)!=$null)
        {
            # ip is already blocked
            xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)|callid=$ci\n");
            exit;
        }
        if (!pike_check_req())
        {
            xlog("L_ALERT","[$timef(%Y%m%d%H%M%S)] ALERT: pike blocking $rm from $fu (IP:$si:$sp)|callid=$ci\n");
            $sht(ipban=>$si) = 1;
            exit;
        }
    }
#!endif

    if(!sanity_check("1511", "7"))
    {
#!ifdef USE_STATSD
        statsd_incr("voip.sipHandleError._t_moduleName." + MYNAME);
#!endif
        xlog("L_ERR","key=sipHandleError|code=400|debug=sendReplyLocally sanity_check fail|callid=$ci\n");
        if(is_method("INVITE")) {
            $avp(cdr) = $ci + "||||" + $fU + "|" + $tU + "|||" + $si + "|" + $sp + "||" + $TS + "||||||||" + $TS + "|;cause=115;text=\"CLPSS_SANITYFAIL\"|CLPSS_4.1.4|404|0";
            route(cdr_record);
        }
        send_reply("400", "Bad Request - rU,tU or fU length error");
        exit;
    }
}
### REQINIT END ###






# Handle requests within SIP dialogs
### WITHINDLG START ###
route[WITHINDLG] {
    if (has_totag()) {
        # sequential request withing a dialog should
        # take the path determined by record-routing
        if (loose_route()) {
            route(DLGURI);

            if ( is_method("NOTIFY") ) {
                # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
                record_route_preset(LOCALIP+":"+PORT);				
            }
            route(RELAY);
        } else {
            if (is_method("SUBSCRIBE") && uri == myself) {
                # in-dialog subscribe requests
                route(PRESENCE);
                exit;
            }
            if ( is_method("ACK") ) {
                if ( t_check_trans() ) {
                    # no loose-route, but stateful ACK;
                    # must be an ACK after a 487
                    # or e.g. 404 from upstream server
                    route(RELAY);
                } else {
                    # ACK without matching transaction ... ignore and discard
                    exit;
                }
            }
#!ifdef USE_STATSD
            statsd_incr("voip.sipHandleError._t_moduleName." + MYNAME);
#!endif
            xlog("L_ERR","key=sipHandleError|code=404|reason=Not here|debug=sendReplyLocally, WITHINDLG, $rm, $route_uri|callid=$ci\n");
            sl_send_reply("404","Not here");
        }
        exit;
    }
}
### WITHINDLG END ###



# Handle SIP registrations
route[REGISTRAR] {
    if (is_method("REGISTER"))
    {
        if (!save("location",0x04)) {
            $var(rc) = $rc;
#!ifdef USE_STATSD
            statsd_incr("voip.REGISTER.Error._t_moduleName." + MYNAME);
#!endif
            xlog("L_ERR","key=REGISTER.Error|rc=$var(rc)|debug=save location fail|callid=$ci\n");
            sl_reply_error();
            exit;
        }

        if(is_present_hf("Expires") && $(hdr(Expires){s.int})>0)
        {
            if(!redis_cmd("redis01", "SETEX k001$fU 3600 " + LOCALIP, "r")) 
            {
#!ifdef USE_STATSD
                statsd_incr("voip.redisFail._t_moduleName." + MYNAME);
#!endif
                xlog("L_ERR","key=redisError|errorType=$redis(r=>type)|errorVal=$redis(r=>value)|errorInfo=$redis(r=>info)|cmd=SET k001$fU "+LOCALIP+"|callid=$ci\n");
            }

            #key: ytx001{voip号码}
            #value: {"server_ip": "192.168.1.1", "server_port":8880, "client_ip": "192.168.1.1"}
            $var(value)="{\"server_ip\":\"" + LOCALIP + "\",\"server_port\":" + PORT + ",\"client_ip\":\"" + $src_ip + "\"}";
            if(!redis_cmd("redis00", "SETEX ytx001$fU 3600 $var(value)", "r")) 
            {
                xlog("L_ERR","key=redisError|errorType=$redis(r=>type)|errorVal=$redis(r=>value)|errorInfo=$redis(r=>info)|cmd=SETEX ytx001$fU 3600 $var(value)|callid=$ci\n");
            }


            $var(sisp) = $si + ":" + $sp;   
            if($var(sisp) != $sht(reguserlist=>$fU))
            {
                xlog("L_NOTICE","key=REGISTER ip change|fU=$fU|sisp=$var(sisp)|old=$sht(reguserlist=>$fU)|callid=$ci\n");
                if(($(tU{s.len}) == 14 && $sht(userstatelist=>$(tU{s.substr,0,6})) == 1) ||
                        ($(tU{s.len}) == 16 && $sht(userstatelist=>$(tU{s.substr,0,8})) == 1))
                {
                    xlog("L_NOTICE","key=info|debug=send MESSAGE to PGMIP:9012;udp|callid=$ci\n");
                    $uac_req(method)="MESSAGE";
                    $uac_req(ruri)="sip:" + $tU + "@" + PGMIP + ":9012;transport=udp";
                    $uac_req(furi)="sip:ccp@" + LOCALIP + ":"+PORT;
                    $uac_req(turi)="sip:" + $tU + "@" + LOCALIP + ":"+PORT;
                    $uac_req(hdrs)="Content-Type: text/plain\r\n";
                    #$uac_req(hdrs)=$cT;    
                    $uac_req(body)="type=4\r\n<state>1</state>";
                    uac_req_send();
                } 

                if($sht(reguserlist=>$fU) != 0)
                {
                    xlog("L_NOTICE","key=info|debug=force unregister|callid=$ci\n");
                    set_forward_no_connect();
                    set_forward_close();

                    $uac_req(method)="MESSAGE";
                    $uac_req(ruri)="sip:" + $fU + "@" + $sht(reguserlist=>$fU) + ";transport=tcp";
                    $uac_req(furi)="sip:" + $fU + "@" + LOCALIP + ":"+PORT; 
                    $uac_req(turi)="sip:" + $fU + "@" + LOCALIP + ":"+PORT; 
                    $uac_req(hdrs)="Content-Type: text/plain\r\n";                    
                    $uac_req(body)="type=2";
                    uac_req_send();
                }         
            }         
            $sht(reguserlist=>$fU) = $si + ":" + $sp;

           if(($(tU{s.len}) == 14 && $sht(pushlist=>$(tU{s.substr,0,6})) == 1) ||
           		($(tU{s.len}) == 16 && $sht(pushlist=>$(tU{s.substr,0,8})) == 1))
          {
             m_dump("sip:$tU@" + LOCALIP + ":" + PORT);
          } 
     }
     else
     {
            if ( search_hf("P-Call-UserData", "auth=temp", "a") ) 
            {
                if (!redis_cmd("redis01", "DEL k017$fU", "r")) {
                    xlog("L_ERR","key=redisError|errorType=$redis(r=>type)|errorVal=$redis(r=>value)|errorInfo=$redis(r=>info)|cmd=DEL k017$fU|callid=$ci\n");
#!ifdef USE_STATSD
                    statsd_incr("voip.redisFail._t_moduleName." + MYNAME);
#!endif
                }
            }
            $sht(reguserlist=>$fU) = "0";

            if(($(tU{s.len}) == 14 && $sht(userstatelist=>$(tU{s.substr,0,6})) == 1) ||
                    ($(tU{s.len}) == 16 && $sht(userstatelist=>$(tU{s.substr,0,8})) == 1))
            {
                $uac_req(method)="MESSAGE";
                $uac_req(ruri)="sip:" + $tU + "@" + PGMIP + ":9012;transport=udp";
                $uac_req(furi)="sip:ccp@" + LOCALIP + ":"+PORT;
                $uac_req(turi)="sip:" + $tU + "@" + LOCALIP + ":"+PORT;
                $uac_req(hdrs)="Content-Type: text/plain\r\n";
                #$uac_req(hdrs)=$cT;
                $uac_req(body)="type=4\r\n<state>0</state>";
                uac_req_send();
            } 
        }
        exit;
    }
}



# USER location service
route[LOCATION] {
    if (!lookup("location")) {
        $var(rc) = $rc;
#!ifdef USE_STATSD
        statsd_incr("voip.REGISTER.Error._t_moduleName." + MYNAME);
#!endif
        xlog("L_ERR","key=REGISTER.Error|rc=$var(rc)|debug=lookup location fail|callid=$ci\n");
        switch ($var(rc)) {
            case -1:
            case -3:
                route(CallRoute_DISPATCH);
                exit;
            case -2:
                send_reply("405", "Method Not Allowed");
                exit;
        }
    }
    route(RELAY);
    exit;
}

# Presence server route
route[PRESENCE] {
    if(!is_method("PUBLISH|SUBSCRIBE"))
        return;

#!ifdef WITH_PRESENCE
    if (!t_newtran())
    {
        sl_reply_error();
        exit;
    };

    if(is_method("PUBLISH"))
    {
        handle_publish();
        t_release();
    }
    else
        if( is_method("SUBSCRIBE"))
        {
            handle_subscribe();
            t_release();
        }
    exit;
#!endif

    # if presence enabled, this part will not be executed
    if (is_method("PUBLISH") || $rU==$null)
    {
        xlog("L_ERR","key=InvalidRequestURI|method=PUBLIST|callid=$ci\n");
        sl_send_reply("404", "Not here");
        exit;
    }
    return;
}

# Authentication route
### AUTH START ###
route[AUTH] {
#!ifdef WITH_AUTH

#!ifdef WITH_IPAUTH
    if((!is_method("REGISTER")) && allow_source_address())
    {
        # source IP allowed
        return;
    }
#!endif

    $var(sisp) = $si + ":" + $sp;  
    if (!is_method("REGISTER") && !is_method("INVITE") && $var(sisp) == $sht(reguserlist=>$fU))   
    {
        return;      
    }

    if (redis_cmd("redis01", "GET k017$fU", "r") && $redis(r=>value)!=$null && $redis(r=>value)!="") {
        if (!pv_auth_check("$fd","$redis(r=>value)" ,"0", "1")) {
            auth_challenge("$fd", "0");
            exit;
        } else {
            xdbg("done\n");
            if(!is_method("REGISTER|PUBLISH"))
                consume_credentials();
            return;
        }
    }
    if ( search_hf("P-Call-UserData", "auth=temp", "a") ) {
        xlog("L_ERR","key=REGISTER fail|type=authtemp|redis_value=$redis(r=>value)|debug=invalid redis value|callid=$ci\n");
        send_reply("433", "Forbidden");
        exit;
    } else {
        if (!auth_check("$fd", "subscriber", "1", "$var(password)")) {
            auth_challenge("$fd", "0");
            exit;
        }
        xdbg("got password for user: $fU, passowrd: $var(password)\n");
        if($var(password)!=$null && $var(password)!="" && !redis_cmd("redis01", "SETEX k017$fU 604800 $var(password)", "r")) 
        {
            xlog("L_ERR","key=redisError|errorType=$redis(r=>type)|errorVal=$redis(r=>value)|errorInfo=$redis(r=>info)|cmd=SET k001$fU "+LOCALIP+"|callid=$ci\n");
        }
    }

    # user authenticated - remove auth header
    if(!is_method("REGISTER|PUBLISH"))
        consume_credentials();
#!endif
}
### AUTH END ###



# Caller NAT detection route
route[NATDETECT] {
#!ifdef WITH_NAT

    $avp(kmtag)=0;
    if($(rU{s.substr,0,2})=="km")
    {
        if (!allow_source_address())   
        {
            xlog("L_ERR","key=ipban|src_ip=$si|src_port=$sp|msg=$mb|callid=$ci\n");
#!ifdef USE_STATSD
            statsd_incr("voip.ipban._t_moduleName." + MYNAME);
#!endif  
            exit;
        }
        strip(2);
        $avp(kmtag)=1;  
    }

    force_rport();
    if (nat_uac_test("19")||nat_uac_test("64")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } 
        else 
        {
            if ( !search_hf("Record-Route", "sip", "a") ) 		    
            {
                if ( !search_hf("Contact", "alias", "a") )
                {
                    if(!add_contact_alias())
                    { 					           
#!ifdef USE_STATSD
                        statsd_incr("voip.shouldNotHappen._t_moduleName." + MYNAME);
#!endif  
                        xlog("L_ERR","key=shouldNotHappen|method=$rm|msg=$mb|callid=$ci\n");
                        send_reply("400", "Bad request");
                        exit;
                    };	
                }
            }				
        }
    }
#!endif
    return;
}



### SIP MESSAGE processing ###
route[MSG] {
    if (!is_method("MESSAGE"))
        return;


    if($avp(kmtag)==0 && $hdr(X-Extra)!="ko" && $(rU{s.substr,0,1})!="g" && $(rU{s.substr,0,1})!="G")
    {
        if($(rb{s.substr,0,8})=="type=0\r\n" && $(rb{s.substr,0,11})!="type=0\r\n[[[")
        {
            search_append_body("type=0\r\n", "[[[" + $timef(%Y%m%d%H%M%S) + "]]]\r\n");
            msg_apply_changes();
        }    
    }   

    if($avp(kmtag)==1)
    {
        if($hdr(X-Extra)!="ko")
        {
            #if use ou,username of silo may be kmxxx if use ru,domain of silo may be client ip if use tu username of silo may be gxxx	  
            m_store_all("sip:$rU@" + LOCALIP + ":"+PORT);
        }   	  

        if (!lookup("location"))
        {  
            #if use ou,username of silo may be kmxxx if use ru,domain of silo may be client ip if use tu username of silo may be gxxx	  
            m_store("sip:$rU@" + LOCALIP + ":"+PORT);
            sl_send_reply("404", "Not Found");
            exit;
        }
        else
        {	       
            if($hdr(X-Extra)!="ko")
            {
                t_on_failure("FAIL_MSG_KM_PP");
            }
            t_relay();
            exit;
        }
    }

    $avp(srvreqtag)=0;
    if (!allow_source_address())   
    {
        $var(sisp) = $si + ":" + $sp;
        if ($var(sisp) != $sht(reguserlist=>$fU))   
        { 
            xlog("L_ERR","key=sipHandleError|432 leave or log in some elsewhere,please relogin|callid=$ci\n");
            send_reply("432", "leave or log in some elsewhere,please relogin");
            exit;     
        } 
    }
    else
    {
        $avp(srvreqtag)=1;
    }

    append_to_reply("Date: $timef(%Y%m%d%H%M%S)\r\n");
    sl_send_reply("100", "Trying");

    if($(rU{s.substr,0,2})=="G8")
    {
        xlog("L_NOTICE", "key=G8|ru=$ru|fu=$fu|tu=$tu|callid=$ci\n");
        sl_send_reply("202", "Accepted");

        $uac_req(method)="MESSAGE";
        $uac_req(ruri)="sip:" + $tU + "@" + PGMIP + ":9012;transport=udp";
        $uac_req(furi)=$fu; 
        $uac_req(turi)=$tu;
        $uac_req(hdrs)="Content-Type: text/plain\r\n";
        #$uac_req(hdrs)=$cT;                         
        $uac_req(body)=$rb;
        uac_req_send();
        exit;
    }


    if($(rU{s.substr,0,1})=="g")
    {
        xlog("L_NOTICE", "key=g|ru=$ru|fu=$fu|tu=$tu|callid=$ci\n");
        sl_send_reply("202", "Accepted");

        if(redis_cmd("redis01", "GET k002$rU", "r"))
        {
            $var(ginfolen)=$(redis(r=>value){s.len});
            $var(ginfo) = $redis(r=>value);	

            if($(var(ginfo){s.substr,0,1}) == "0" && $avp(srvreqtag) == 0 )
            {
                xlog("callid=$ci|GET k002$rU: $var(ginfo), first character 0, exit\n");
                exit;
            }
            $var(ncnt) = 1;
            $var(muser_all) = $(var(ginfo){s.select,$var(ncnt),;});	
            $var(bGroupUserTag)=0;
            while($(var(muser_all){s.len}) > 0)
            {
                if(($(fU{s.len})== 14 && $(var(muser_all){s.substr,0,14}) == $fU) ||
                        ($(fU{s.len})== 16 && $(var(muser_all){s.substr,0,16}) == $fU))
                {
                    $var(bGroupUserTag)=1;
                    if(($(fU{s.len})== 14 && $(var(muser_all){s.substr,16,2}) == "#1") ||
                            ($(fU{s.len})== 16 && $(var(muser_all){s.substr,18,2}) == "#1"))
                    {
                        xlog("L_ERR", "key=sipHandleError|debug=$fU is forbidden to  send|callid=$ci\n");
                        exit;
                    }			
                }
                $var(ncnt) = $var(ncnt) + 1;
                $var(muser_all) = $(var(ginfo){s.select,$var(ncnt),;});	
            }

            if($var(bGroupUserTag) == 0)
            {
                xlog("L_ERR","key=sipHandleError|$fU is not Group User|callid=$ci\n");
                exit;
            }		    

            $var(ncnt) = 1;
            $var(muser_all) = $(var(ginfo){s.select,$var(ncnt),;});	
            $var(bGroupUserTag)=0;
            while($(var(muser_all){s.len}) > 0)
            {
                if($(fU{s.len})== 14)
                {
                    $var(muser) = $(var(muser_all){s.substr,0,14});
                    if($var(muser) != $fU)
                    {
                        if($(var(muser_all){s.substr,16,2}) == "#1")
                        {
                           xlog("L_NOTICE","key=#1|debug=$var(muser) don't want to recv|callid=$ci\n");		
                            m_store("sip:" + $var(muser) + "@" + LOCALIP + ":"+PORT); 
                            m_store_all("sip:" + $var(muser) + "@" + LOCALIP + ":"+PORT); 					   
                        }
                        else
                        {
                            xlog("callid=$ci|send MESSAGE: $fu to $tu\n");	
                            $uac_req(method)="MESSAGE";
                            $uac_req(ruri)="sip:" + $var(muser) + "@" + LOCALIP + ":"+PORT;
                            $uac_req(furi)=$fu; 
                            $uac_req(turi)=$tu;
                            $uac_req(hdrs)="Content-Type: text/plain\r\n";
                            #$uac_req(hdrs)=$cT;                         
                            $uac_req(body)=$rb;
                            uac_req_send();
                        }
                    }	

                } else if($(fU{s.len})== 16){

                    $var(muser) = $(var(muser_all){s.substr,0,16});
                    if($var(muser) != $fU)
                    {
                        if($(var(muser_all){s.substr,18,2}) == "#1")
                        {
                            xlog("L_NOTICE","key=#1|debug=$var(muser) don't want to recv|callid=$ci\n");
                            m_store("sip:" + $var(muser) + "@" + LOCALIP + ":"+PORT); 
                            m_store_all("sip:" + $var(muser) + "@" + LOCALIP + ":"+PORT); 					   
                        }
                        else
                        {	
                            $uac_req(method)="MESSAGE";
                            $uac_req(ruri)="sip:" + $var(muser) + "@" + LOCALIP + ":"+PORT;
                            $uac_req(furi)=$fu; 
                            $uac_req(turi)=$tu;
                            $uac_req(hdrs)="Content-Type: text/plain\r\n";
                            #$uac_req(hdrs)=$cT;
                            $uac_req(body)=$rb;
                            uac_req_send();
                        }
                    }		 
                }
                $var(ncnt) = $var(ncnt) + 1;
                $var(muser_all) = $(var(ginfo){s.select,$var(ncnt),;});	
            }				       
        } else {
            xlog("key=redisError|callid=$ci|errorType=$redis(r=>type)|errorVal=$redis(r=>value)|errorInfo=$redis(r=>info)|cmd=GET k002$rU\n");
#!ifdef USE_STATSD
            statsd_incr("voip.regRedisFail._t_moduleName." + MYNAME);
#!endif
        }
        exit;	
    }


    if(redis_cmd("redis01", "GET k001$rU", "r"))
    {
        if(($redis(r=>value)=~"^[0-9|\.]{7,15}$") && $redis(r=>value) != LOCALIP && $redis(r=>value) != INTERNALIP)
        {
            #$du = "sip:" + $redis(r=>value) + ":"+PORT+";transport=" +$pr;
            #$ru = "sip:km" + $rU + "@" + $redis(r=>value) + ":"+PORT+";transport=" +$pr;
            $du = "sip:" + $redis(r=>value) + ":"+PORT+";transport=tcp";
            $ru = "sip:km" + $rU + "@" + $redis(r=>value) + ":"+PORT+";transport=tcp";
            xlog("relay to dest|callid=$ci|ru=$ru|du=$du\n");
            t_relay();
            exit;
        }
        xlog("do not relay|callid=$ci|GET k001$rU: $redis(r=>value)\n");
    } else {
        xlog("key=redisError|callid=$ci|errorType=$redis(r=>type)|errorVal=$redis(r=>value)|errorInfo=$redis(r=>info)|cmd=GET k001$rU\n");
#!ifdef USE_STATSD
        statsd_incr("voip.regRedisFail._t_moduleName." + MYNAME);
#!endif
    }


    if (!lookup("location"))
    {  
        #NEWOLDIM
        #if($avp(newimtag)!=1 && $(tU{s.substr,0,1})!="g" && $(rU{s.substr,0,1})!="g" && $(tU{s.substr,0,1})!="G" && $(rU{s.substr,0,1})!="G")
        #{
        #    route(CallRoute_DISPATCH);
        #} 
        #else
        #{
            xlog("L_NOTICE", "offline message, store|callid=$ci\n");
            #m_store("sip:$rU@" + LOCALIP + ":"+PORT);
            sl_send_reply("202", "Accepted");
        #}
        exit;
    }
    else
    {	       
        if($hdr(X-Extra)!="ko")
        {
            t_on_failure("FAIL_MSG_PP");
        }
        else
        {
            xlog("L_NOTICE","key=ko|X-Extra=ko|ru=$ru|tu=$tu|fu=$fu|callid=$ci\n");		
        }
        t_relay();
        exit;
    }
}




failure_route[FAIL_MSG_PP]
{
   xlog("L_NOTICE","key=FAIL_MSG_PP|ru=$ru|tu=$tu|fu=$fu|callid=$ci\n");		
#   unregister("location", "$ru");

    if (!lookup("location"))
    {  
        xlog("callid=$ci|offline, store message\n");
        m_store("sip:$rU@" + LOCALIP + ":"+PORT);
        exit;
    }
    else
    {
        if($(rb{s.substr,0,6})!="type=2")
        {
            xlog("callid=$ci|is not type=2, relay\n");
            append_branch(); 
            t_on_failure("FAIL_MSG_PP2");
            t_relay();
        }
        else
        {
            xlog("callid=$ci|is type=2, exit\n");
            exit;
        }
    }
}
failure_route[FAIL_MSG_PP2]
{
   xlog("L_NOTICE","key=FAIL_MSG_PP2|ru=$ru|tu=$tu|fu=$fu|callid=$ci\n");		

    if (!lookup("location"))
    {  
        xlog("callid=$ci|offline, store message\n");
        m_store("sip:$rU@" + LOCALIP + ":"+PORT);
        exit;
    }
    else
    {
        if($(rb{s.substr,0,6})!="type=2")
        {
            xlog("callid=$ci|is not type=2, relay\n");
            append_branch(); 
            t_on_failure("FAIL_MSG_PP3");
            t_relay();
        }
        else
        {
            xlog("callid=$ci|is type=2, exit\n");
            exit;
        }
    }
}
failure_route[FAIL_MSG_PP3]
{
   xlog("L_NOTICE","key=FAIL_MSG_PP3|ru=$ru|tu=$tu|fu=$fu|callid=$ci\n");		

    if($TS - $sht(regtime=>$rU)< 10)
    {
        xlog("callid=$ci|less than 10s\n");
        if (!lookup("location"))
        {  
            xlog("callid=$ci|offline, store message\n");
            m_store("sip:$rU@" + LOCALIP + ":"+PORT);
            exit;
        }
        else
        {
            if($(rb{s.substr,0,6})!="type=2")
            {
                xlog("callid=$ci|is not type=2, relay\n");
                append_branch(); 
                t_on_failure("FAIL_MSG_PP4");
                t_relay();
            }
            else
            {
                xlog("callid=$ci|is type=2, exit\n");
                exit;
            }
        }
    }
    else
    {
        xlog("callid=$ci|more than 10s, store messag, exit\n");
        m_store("sip:$rU@" + LOCALIP + ":"+PORT);
        exit;
    }
}

failure_route[FAIL_MSG_PP4]
{
   xlog("L_NOTICE","key=FAIL_MSG_PP4|ru=$ru|tu=$tu|fu=$fu|callid=$ci\n");		
   m_store("sip:$rU@" + LOCALIP + ":" + PORT);    
}




failure_route[FAIL_MSG_KM_PP]
{
    xlog("L_NOTICE","key=FAIL_MSG_KM_PP|ru=$ru|tu=$tu|fu=$fu|callid=$ci\n");
    #unregister("location", "$ru");
    if (!lookup("location"))
    {  
        m_store("sip:$rU@" + LOCALIP + ":"+PORT);
        exit;
    }
    else
    {
        if($(rb{s.substr,0,6})!="type=2")
        {
            append_branch(); 
            t_on_failure("FAIL_MSG_KM_PP2");
            t_relay();
        }
        else
        {
            exit;
        }
    }   
}
failure_route[FAIL_MSG_KM_PP2]
{
    xlog("L_NOTICE","key=FAIL_MSG_KM_PP2|ru=$ru|tu=$tu|fu=$fu|callid=$ci\n");
    if (!lookup("location"))
    {
        m_store("sip:$rU@" + LOCALIP + ":"+PORT);
        exit;
    }
    else
    {
        if($(rb{s.substr,0,6})!="type=2")
        {
            append_branch(); 
            t_on_failure("FAIL_MSG_KM_PP3");
            t_relay();
        }
        else
        {
            exit;
        }
    }     
}
failure_route[FAIL_MSG_KM_PP3]
{
    xlog("L_NOTICE","key=FAIL_MSG_KM_PP3|ru=$ru|tu=$tu|fu=$fu|callid=$ci\n");

    if($TS - $sht(regtime=>$rU)< 10)
    {
        if (!lookup("location"))
        {  
            m_store("sip:$rU@" + LOCALIP + ":"+PORT);
            exit;
        }
        else
        {
            if($(rb{s.substr,0,6})!="type=2")
            {
                append_branch(); 
                t_on_failure("FAIL_MSG_KM_PP4");
                t_relay();
            }
            else
            {
                exit;
            }
        }
    }
    else
    {
        m_store("sip:$rU@" + LOCALIP + ":"+PORT);    
        exit;
    }       
}

failure_route[FAIL_MSG_KM_PP4]
{
   xlog("L_NOTICE","key=FAIL_MSG_KM_PP4|ru=$ru|tu=$tu|fu=$fu|callid=$ci\n");		
   m_store("sip:$rU@" + LOCALIP + ":" + PORT);    
}



# URI update for dialog requests
route[DLGURI] {
#!ifdef WITH_NAT
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
#!endif
    return;
}

# XMLRPC routing
#!ifdef WITH_XMLRPC
route[XMLRPC] {
    # allow XMLRPC from localhost
    if ((method=="POST" || method=="GET")
            && (src_ip==127.0.0.1)) {
        # close connection only for xmlrpclib user agents (there is a bug in
        # xmlrpclib: it waits for EOF before interpreting the response).
        if ($hdr(User-Agent) =~ "xmlrpclib")
            set_reply_close();
        set_reply_no_connect();
        dispatch_rpc();
        exit;
    }
    send_reply("403", "Forbidden");
    exit;
}
#!endif



# manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru|callid=$ci\n");

}

# manage incoming replies
onreply_route[MANAGE_REPLY] {
    xlog("L_NOTICE","key=RECV_REPLY|src_ip=$si|src_port=$sp|code=$rs|ru=$ru|fu=$fu|tu=$tu|reason=$hdr(Reason)|userAgent=$hdr(User-Agent)|callid=$ci\n");
    xlog("L_INFO", "key=RECV_REPLY|msg=$mb|callid=$ci\n"); 

    if(is_method("INVITE")) 
    {
        if (status=~"18[03]") {
            if (!is_avp_set("$avp(ring_ts)")) $avp(ring_ts) = $TS;
        }
        if(status=~"2[0-9][0-9]") {
            if ($sht(callcdrlist=>$ci) == 0 || $(sht(callcdrlist=>$ci){s.select,0,|}) != $ci) {
                #获取到被叫的media ip and media port, voice codec
                $var(media_ip) = "";
                if(sdp_get_line_startswith("$avp(cline)", "c=IN") == 1){
                    $var(media_ip) = $(avp(cline){s.select,2, });
                } else {
                    xlog("L_ERR","key=sdp|debug=can not get sdp line start with c=IN for message $rb|callid=$ci\n");
                }

                $var(media_port) = "";
                $var(voice_codec) = "";
                if(sdp_get_line_startswith("$avp(cline)", "m=audio") == 1){
                    $var(media_port) = $(avp(cline){s.select,1, });
                    $var(voice_codec) = $(avp(cline){s.select,3, });
                } else {
                    xlog("L_ERR","key=sdp|debug=can not get sdp line start with m=audio for message $rb|callid=$ci\n");
                }

                $sht(callcdrlist=>$ci) = $avp(callinfo) + "|" + $avp(dst_ip) + "|" +$avp(dst_port) + "|" + $avp(ring_ts) + "|" + $TS + "|" + $var(media_ip) + "|" + $var(media_port) + "|" + $var(voice_codec);
            }
            $sht(connectedcalls=>$ci) = $(avp(callinfo){s.select,1,|});
        }
    }

    if(status=~"[12][0-9][0-9]")
    {
        if (nat_uac_test("19")||nat_uac_test("64")) 
        {  
            if(($hdr(Record-Route)=~"^.+"+LOCALIP+".+$")||$hdr(Record-Route)=="")
            {
                if (!search_hf("Contact", "alias", "a") )
                {
                    add_contact_alias();
                }
            }					
        }
    }
}

route[timer_options] {
    sht_iterator_start("it", "reguserlist");
    while(sht_iterator_next("it")) {
        if(($(shtitkey(it){s.len})== 14 && $sht(userstatelist=>$(shtitkey(it){s.substr,0,6})) != 0 && $shtitval(it) != 0) ||
                ($(shtitkey(it){s.len})== 16 && $sht(userstatelist=>$(shtitkey(it){s.substr,0,8})) != 0 && $shtitval(it) != 0)) 
        {
            $uac_req(method)="OPTIONS";
            $uac_req(ruri)="sip:" + $shtitkey(it) + "@" + LOCALIP + ":"+PORT;
            $uac_req(furi)="sip:ss@" +  LOCALIP + ":"+PORT;
            $uac_req(turi)="sip:" + $shtitkey(it) + "@" + LOCALIP + ":"+PORT;
            uac_req_send();
        }   
    }
    sht_iterator_end("it");
}


# manage failure routing cases
failure_route[MANAGE_FAILURE] {
    $var(code) = $T_reply_code;
    $var(rcode) = $T_reply_code;
#!ifdef USE_STATSD
    statsd_incr("voip.regclpss.SIPErrorReply._t_moduleName." + MYNAME + "._t_code." + $var(code));
#!endif
    $var(reason_org) = $T_rpl($hdr(Reason));
    $var(ua_org) = $T_rpl($hdr(User-Agent));
    $var(reason) = $(var(reason_org){re.subst,/ //g});
    $var(ua) = $(var(ua){re.subst,/ //g});
    xdbg("reason_org: $var(reason_org), ua_org: $var(ua_org), reason: $var(reason), ua: $var(ua)|callid=$ci\n");

    #sht_rm_name_re("callidlist=>$ci");

    if ($var(code) == "301") {
        $var(contact) = $T_rpl($hdr(Contact));
        if ($(var(contact){s.substr,0,1}) == '<') {
            $var(tmp) = $(var(contact){s.strip,1});
            $var(contact) = $(var(tmp){s.striptail,1});
        }
        xlog("L_NOTICE", "contact=$var(contact)|will send to this|callid=$ci\n");
        t_drop_replies();
        $du = $var(contact);
        route(RELAY);
        exit;
    }

#!ifdef WITH_BLOCK3XX
	# block call redirect based on 3xx replies.
	if (t_check_status("3[0-9][0-9]")) {
        xlog("L_ERR","key=REDIRECT|debug=a redirect response received|callid=$ci\n");
		#t_reply("404","Not found");
        $avp(cdr) = $avp(callinfo) + "|" + $avp(dst_ip) + "|" +$avp(dst_port) + "|" + $avp(ring_ts) + "|||||" + $TS + "|" + $var(reason) + "|" + $var(ua) + "|" + $T_reply_code + "|0";
        route(cdr_record);
		drop;
		exit;
	}
#!endif

    #local timeout
    if (t_branch_timeout() && !t_branch_replied()){
        xlog("L_ERR","key=branch local timeout|callid=$ci\n");
        $var(reason) = "Q.850;cause=31;text=\"CLPSS_TIMEOUT\"";
        $var(ua) = "CLPSS_4.1.4.2";
        $var(code) = "408";
        $var(rcode) = 460;
    }


    $var(result) = "0";
    if (t_is_canceled()) {
        $var(cdrinfo) = $sht(callcdrlist=>$ci);
        $var(reason) = $(var(cdrinfo){s.select,0,|});
        $var(ua) = $(var(cdrinfo){s.select,1,|});
        xdbg("reason: $var(reason), ua: $var(ua)|callid=$ci\n");
        $var(result) = "2";
    }
    $avp(cdr) = $avp(callinfo) + "|" + $avp(dst_ip) + "|" +$avp(dst_port) + "|" + $avp(ring_ts) + "|||||" + $TS + "|" + $var(reason) + "|" + $var(ua) + "|" + $var(code) + "|" + $var(result);
    route(cdr_record);

    if ($var(rcode) == 460) {
        //重新路由
        revert_uri();
        $mf=DCNUM;
        if (!cr_next_domain("$avp(carrier)", "$avp(domain)", "$avp(prefix)",
                    "$avp(host)", "$var(rcode)", "$avp(domain)")) {
            xlog("key=reroute|cr_next_domain failed|callid=$ci\n");
            exit;
        }     
        if (!cr_route("$avp(carrier)", "$avp(domain)", "$avp(prefix)", "$rU",
                    "call_id")) {
            xlog("key=reroute|cr_route failed|callid=$ci\n");
            exit;
        }     
        xlog("key=reroute|next_domain=$avp(domain)|ru=$ru|cr_route next carrier|callid=$ci\n");
        $avp(host)= $rd+":"+$rp;
        route(RELAY);
    } else {
        exit;
    }
}


event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    xlog("L_DBG", "HTTP Request Received|callid=$ci\n");

    if ($hdr(Upgrade)=~"websocket"
            && $hdr(Connection)=~"Upgrade"
            && $rm=~"GET") {

        # Validate Host - make sure the client is using the correct
        # alias for WebSockets
        if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
            xlog("L_WARN", "Bad host $hdr(Host)|callid=$ci\n");
            xhttp_reply("403", "Forbidden", "", "");
            exit;
        }

        # Optional... validate Origin - make sure the client is from an
        # authorised website.  For example,
        #
        # if ($hdr(Origin) != "http://communicator.MY_DOMAIN"
        #     && $hdr(Origin) != "https://communicator.MY_DOMAIN") {
        #       xlog("L_WARN", "Unauthorised client $hdr(Origin)|callid=$ci\n");
        #       xhttp_reply("403", "Forbidden", "", "");
        #       exit;
        # }

        # Optional... perform HTTP authentication

        # ws_handle_handshake() exits (no further configuration file
        # processing of the request) when complete.
        if (ws_handle_handshake())
        {
            # Optional... cache some information about the
            # successful connection
            exit;
        }
    }
    xhttp_reply("404", "Not found", "", "");
}


route[cdr_record] {
    $var(mip) = LOCALIP;
    $var(ver) = VERSION;
    xlog("LOG_LOCAL1", "L_NOTICE","regClpss|$var(ver)|$var(mip)|$avp(cdr)\n");
    sht_rm_name_re("callcdrlist=>$ci");
}

#!ifdef USE_STATSD
route[stats_rt] {
    statsd_gauge("voip.regclpss.answeredCallALL._t_moduleName." + MYNAME, (str)$shtcn(connectedcalls=>**));
}
#!endif


route[route2next]{
	#路由1
    xlog("L_NOTICE","key=find route1|carrier=$avp(ipgroup)|domain=$avp(SipPrefix)|scan_prefix=$avp(scanPrefix)|callid=$ci\n");
    $avp(carrier) = $avp(ipgroup);
    $avp(domain) = $avp(SipPrefix);
    $avp(prefix) = $avp(scanPrefix);
    $mf=DCNUM;
    if(!cr_route("$avp(ipgroup)", "$avp(SipPrefix)", "$avp(scanPrefix)", "$rU", "call_id","$avp(desc)")) {
        xlog("L_NOTICE","key=cr_route fail|rU=$rU|debug=no route 1|callid=$ci\n");
		#路由2
        xlog("L_NOTICE","key=find route2|carrier=$avp(ipgroup)|domain=default|scan_prefix=$avp(scanPrefix)|callid=$ci\n");
        $avp(carrier) = $avp(ipgroup);
        $avp(domain) = "default";
        $avp(prefix) = $avp(scanPrefix);
        if(!cr_route("$avp(ipgroup)", "default", "$avp(scanPrefix)", "$rU", "call_id","$avp(desc)")) {
            xlog("L_NOTICE","key=cr_route fail|rU=$rU|debug=no route 2|callid=$ci\n");
            if($avp(ipgroup)=="default" ) {
#!ifdef USE_STATSD 
                statsd_incr("voip.sipHandleError._t_moduleName." + MYNAME);
#!endif
                xlog("L_ERR","key=cr_route fail|carrier=default|domain=default|rU=$rU|debug=no route 3|callid=$ci\n");
                $avp(cdr) = $avp(callinfo) + "||||||||" + $TS + "|;cause=112;text=\"CLPSS_NoCrRoute\"|CLPSS_4.1.4|404|0";
                route(cdr_record);
                sl_send_reply("404", "No route to destination");
                exit;
            }
			#路由3
            xlog("L_NOTICE","key=find route3|carrier=default|domain=$avp(SipPrefix)|scan_prefix=$avp(scanPrefix)|callid=$ci\n");
            $avp(carrier) = "default";
            $avp(domain) = $avp(SipPrefix);
            $avp(prefix) = $avp(scanPrefix);
			if(!cr_route("default", "$avp(SipPrefix)", "$avp(scanPrefix)", "$rU", "call_id","$avp(desc)")) {
                xlog("L_NOTICE","key=cr_route fail3|rU=$rU|debug=no route 3|callid=$ci\n");
				
                #默认路由4
                xlog("L_NOTICE","key=find route4|carrier=default|domain=default|scan_prefix=$avp(scanPrefix)|callid=$ci\n");
                $avp(carrier) = "default";
                $avp(domain) = "default";
                $avp(prefix) = $avp(scanPrefix);
                if(!cr_route("default", "default", "$avp(scanPrefix)", "$rU", "call_id","$avp(desc)")){
#!ifdef USE_STATSD
                    statsd_incr("voip.sipHandleError._t_moduleName." + MYNAME);
#!endif
                    xlog("L_ERR","key=sipHandleError cr_route fail|rU=$rU|debug=no route 4|callid=$ci\n");
                    $avp(cdr) = $avp(callinfo) + "||||||||" + $TS + "|;cause=112;text=\"CLPSS_NoCrRoute\"|CLPSS_4.1.4|404|0";
                    route(cdr_record);
                    sl_send_reply("404", "No route to destination");
                    exit;
                }
            }
        }
	}
    $avp(dst_ip) = $(ru{uri.host});
    $avp(dst_port) = $(ru{uri.port});
    $avp(host)= $rd+":"+$rp;    
    $ru = $ru + ";transport=" +$pr;
    xlog("L_NOTICE","key=cr_route success|ru=$ru|callid=$ci\n");
    route(RELAY);
}


route[write_version] {
    ###写入自身的版本信息,只在启动的时候被触发
    $var(ver) = VERSION;
    $var(interip) = LOCALIP;
    $var(port) = PORT;
    sql_query("ca", "UPDATE sys_cfg_clpss_module t1, (SELECT id from sys_cfg_device_info where ext_ip=\"$var(interip)\") t2 SET t1.curr_version=\"$var(ver)\" WHERE t1.device_id=t2.id AND t1.ss_port=$var(port)", "ra");
    timer_enable("version", 0);
}
